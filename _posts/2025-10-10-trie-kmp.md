---
layout: post
title: Trie & KMP
date: 2025-10-10 06:34 +0000
categories: [Algorithm, String]
tags: [Trie, KMP, Aho–Corasick automaton]
math: true
---
## **KMP Algorithm**

### **What's the function of KMP?**

When we have a text and a string, we want to know whether the string is in it or not, if it is in the text, how many times it appeared? If we use the naive algorithm, it will consume $O(n \cdot m)$(m is the length of the passage and the n is the length of the string) because we should compare one by one. But if the string and the text have some rules, for example, *text = abcadabcab*, the string is *abcab*. In this case, apparently we have better method to solve it. The algorithm is **KMP**, which full name is **Knuth–Morris–Pratt Algorithm**. And we define the string we need to find in the text as *pattern*.

### **The logic of KMP and proff**

We need two pointers: the pattern pointers and the text pointers to compare.

When we encounter a mismatch, it means that the characters we compared previously must be equal. We can check the LPS length of the previous character. If this length is greater than 0, it means that the pattern ending with the previous character has equal prefix and suffix. We can simply move the prefix to the suffix position and compare the first character after the prefix with the character currently pointed to by the text pointer. If they are not equal, we repeat this process until they are equal or fall back to the first character. If the first character is also not equal, we simply move the text pointer and compare again. This way, you don't have to move characters one by one, which significantly improves the matching speed.

Is it always right?
***Proof:***

*When text[i] not equal to pattern[j]*

*Knowing lps[j - 1] = t, t <= j - 1 => pattern[0 ~ t-1] = pattern[j - t ~ j - 1]*

*and text[i - j ~ i - 1] = pattern[0 ~ j - 1] => text[i - t ~ i - 1] = pattern[j - t ~ j - 1]*

=> text[i - t ~ i - 1] = pattern[0 ~ t-1]

*That means existing the prefix of pattern which equals to text[i - t ~ i - 1]*

**We don’t need to compare from the beginning!**

So the C++ code is:

```c++
void KMPsearch(string& text, string& pattern)
{
    int n = text.size();
    int m = pattern.size();
    vector<int>lps = LPSlength(pattern);
    int i = 0, j = 0;
    while(i < n)
    {
        if(text[i] == pattern[j])
        {
            i++; j++;
        }
        if(j == m) j = lps[j - 1]; // if we want to know how many times the pattern appeared, we can add a count to contain it.
        else if(i != n && text[i] != pattern[j])
        {
            if(j != 0) j = lps[j - 1];// fall back
            else i++;
        }
    }    
}
```

### **LPS, How to get LPS length**

Using the example I have mentioned above, when the prefix ***abca*** of the string ***abcab*** have been compared, ***b*** is not equal to ***d***. In that moment, we can actually move the first ***a*** of the string to the second ***a*** of the text, instead of just moving ***a*** to align ***b***, which is the second letter of the text. Repeat this process. Moving like this we can speed up the matching process obviously. But that's a question: What can we do to move like this? Introducing a concept: LPS(Longest prefix which is also suffix), it means we should find the length of the longest proper prefix which is also a suffix. A proper prefix is a prefix that doesn’t include whole string. In a text, for example: ***ababc***, we need to know the LPS length ending at each character. For ***a***, it is single character, and we defined its LPS length is 0. For ***ab***, the LPS length is 0 because the prefix not equal to suffix. For ***aba***, the prefix ***a*** equal to the suffix so the LPS length is 1. For ***abab***, the prefix is ***ab***, the suffix is ***ab***, so the length of LPS is 2. For ***ababc***, its LPS length is 0. We should record the LPS length of each character in an array [0, 0, 1, 2, 0]. The index is equal to the index of the string.

Knowing what the LPS length is, how can we get it? We will use a leading pointer and a trailing pointer. If equal, move forward both; If not equal, the trailing one fall back and compare again. If still not equal, move the leading one only. So the key to get the LPS length is the **fall back** logic. We need to borrow the logic of KMP fall back pattern pointer, meaning that we consider the first character to the leading pointer as the *text* and the first character to the trailing pointer as the *pattern*. The fall back logic is same as *move the prefix to the suffix position and compare the first character after the prefix with the character currently pointed to by the text pointer*. Just replace the move prefix with move trailing pointer. And don't forget to record the LPS length of each character!

Achieve in the c++:

```c++
vector<int> LPSlength(string& pattern)
{
    int m = pattern.size();
    vector<int>lps(m, 0);
    int len = 0;
    for(int i = 1; i < m;)
    {
        if(pattern[i] == pattern[len])
        {
            lps[i++] = ++len;
        }
        else
        {
            if(len != 0) len = lps[len - 1];
            else lps[i++] = 0;
        }
    }
}
```

### **Time complexity**

Because the logic of KMP searching and LPS length computing is same, so we just analyze one of them. So we analyze the KMP search: the text pointer always move forward, so it will consume $O(n)$ (n is the length of the text). Even the worst situation, the times of pattern pointer move back is linear too, and it won't beyond n times. So the KMP search is $O(n)$, equal to the text length. So the LPS length computing is $O(m)$, equal to the pattern length.
Above all, the time complexity of KMP is $O(n + m)$, better than $O(nm)$.

## **Trie**

### **what is Trie**

A Trie is a tree-like structure that stores strings by their prefixes. For example, I want to store the words: *"cat", "cap", "dog"*. It the Trie will be like:

![alt text](/assets/images/Trie.jpeg)

In this way we can did many operations such as insert, search and so on. By the way, if we insert cat, we can set whether the c or ca can be finded or not.

So we can use code to translate this graph:

```c++
struct TrieNode{
    TrieNode* children[1000];// maybe it will contain many characters instead of only the 26 letters
    bool isEndOfWord;
    TrieNode(){
        isEndOfWord = false;
        for(int i = 0; i < 1000; ++i) children[i] = nullptr;
    }
};

class Trie{
private:
    TrieNode* root;
public:
    Trie(){
        root = new TrieNode();
    }
};
```

This is the Trie. We will add some functions to push it to work.

```c++
void insert(string& s){
    TrieNode* node = root;
    for(auto c : s)
    {
        int i = c - 'a';
        if(!node -> children[i]) node -> children[i] = new TrieNode();
        node = node -> children[i];
    }
    node -> isEndOfWord = true;
}

void search(string& s){
    TrieNode* node = root;
    for(auto c : s)
    {
        int i = c - 'a';
        if(!node -> children[i]) return false;
        node = node -> children[i];
    }
    return node -> isEndOfWord;
}
```

There are too many operations that Trie can do. And most of them can be expended based on these two basic functions.

### **Fail link**

### **Aho-Corasick automaton**
